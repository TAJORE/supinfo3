<?php

namespace AppBundle\Repository;

use App\Rest\RestClient;
use AppBundle\Entity\User;
use Doctrine\ORM\Mapping;
use Doctrine\ORM\EntityManager;
use Doctrine\ORM\NoResultException;
use Symfony\Component\HttpFoundation\Cookie;
use Symfony\Component\Security\Core\Exception\UnsupportedUserException;
use Symfony\Component\Security\Core\Exception\UsernameNotFoundException;
use Symfony\Component\Security\Core\User\UserInterface;
use Symfony\Component\Security\Core\User\UserProviderInterface;

/**
 * UserRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class UserRepository extends \Doctrine\ORM\EntityRepository implements UserProviderInterface
{
    public function __construct(EntityManager $entityManager, Mapping\ClassMetadata $class)
    {
        parent::__construct($entityManager, $class);
    }

    /**
     * @param $email
     * @param $password
     *
     * @return User
     */
    public function getLogin($email, $password)
    {

        $user = null;

        $data = ['email' => $email, 'password' => $password];

        $client = new RestClient(RestClient::$POST_METHOD, 'login', null, $data);

        if($client->getStatusCode() == 200)
        {
            $contents = \GuzzleHttp\json_decode($client->getContent());
            //dd($contents->data);
            $user = $this->getGenericUser($contents->data);
            var_dump($user);
            die();
            if(!is_null($user)){
                //Log::info("Token => ".RestClient::getAccessToken());
                //Cookie::queue(Cookie::make(RestClient::$TOKEN_COOKIE_NAME, \GuzzleHttp\json_encode($user->token)), 60);
            }
        }

        return $user;
    }

    /**
     * Loads the user for the given username.
     *
     * This method must throw UsernameNotFoundException if the user is not
     * found.
     *
     * @param string $username The username
     *
     * @return UserInterface
     *
     * @throws UsernameNotFoundException if the user is not found
     */
    public function loadUserByUsername($username)
    {
        try
        {
            $user = null;

            $token = ""; //\GuzzleHttp\json_decode(Cookie::get(RestClient::$TOKEN_COOKIE_NAME));

            $client = new RestClient(RestClient::$GET_METHOD, 'users?email='.$username, $token);

            if($client->getStatusCode() == 200)
            {
                $contents = \GuzzleHttp\json_decode($client->getContent());
                var_dump($contents->data);
                die();
                $user = $this->getGenericUser($contents->data);
            }

            return $user;

        } catch (NoResultException $e) {
            $user = null;
        }

        return $user;
    }

    /**
     * Refreshes the user for the account interface.
     *
     * It is up to the implementation to decide if the user data should be
     * totally reloaded (e.g. from the database), or if the UserInterface
     * object can just be merged into some internal array of users / identity
     * map.
     *
     * @param UserInterface $user
     *
     * @return UserInterface
     *
     * @throws UnsupportedUserException if the account is not supported
     */
    public function refreshUser(UserInterface $user)
    {
        $class = get_class($user);

        if (!$this->supportsClass($class)) {
            throw new UnsupportedUserException(sprintf('Instances of "%s" are not supported.', $class));
        }

        return $this->loadUserByUsername($user->getUsername());
    }

    /**
     * Whether this provider supports the given user class.
     *
     * @param string $class
     *
     * @return bool
     */
    public function supportsClass($class)
    {
        return $this->getEntityName() === $class || is_subclass_of($class, $this->getEntityName());
    }

    /**
     * Get the generic user.
     *
     * @param  mixed  $user
     * @return User|null
     */
    protected function getGenericUser($user)
    {
        if (! is_null($user)) {
            $obj = new User();
            /*$obj->id = $user->id;
            $obj->firstname = $user->firstname;
            $obj->lastname = $user->lastname;
            $obj->email = $user->email;
            $obj->confirmed = $user->confirmed;
            $obj->password = $user->password;
            $obj->pseudo = $user->pseudo;
            $obj->gender = $user->gender;
            $obj->birth = $user->birth;
            $obj->phone = $user->phone;
            $obj->address = $user->address;
            $obj->avatar = $user->avatar;
            $obj->last_login = $user->last_login;
            $obj->discriminator = $user->discriminator;
            $obj->social_provider = $user->social_auth_provider;
            $obj->social_id = $user->social_id;
            $obj->social_avatar = $user->social_avatar;
            $obj->setCreatedAt(explode('.',$user->created_at->date)[0]);
            $obj->setUpdatedAt(explode('.',$user->updated_at->date)[0]);
            $obj->deleted_at = $user->deleted_at;
            $obj->token = $user->token;
            $obj->role = $this->getRole($user->roles->data[0]);*/

            return $obj;
        }

        return null;
    }
}
